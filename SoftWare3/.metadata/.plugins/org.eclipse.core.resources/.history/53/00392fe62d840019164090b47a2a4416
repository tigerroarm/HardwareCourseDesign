/*
 * sdread.c
 *
 *  Created on: 2019年5月26日
 *      Author: 12757
 */


#include <errno.h>
#include <priv/alt_file.h>
#include <io.h>
#include <stdio.h>
#include <string.h>
#include "sdread.h"


//直接从Altera_UP_SD_Card_Avalon_Interface.c里复制的宏定义和结构体定义

///////////////////////////////////////////////////////////////////////////
// Local Define Statements
///////////////////////////////////////////////////////////////////////////

#define CHAR_TO_UPPER(ch)	((char) (((ch >= 'a') && (ch <= 'z')) ? ((ch-'a')+'A'): ch))

// Data Buffer Address
#define SD_CARD_BUFFER(base, x)			(base + x)
// 128-bit Card Identification Number
#define SD_CARD_CID(base, x)			(base + 0x0200 + x)
// 128-bit Card Specific Data Register
#define SD_CARD_CSD(base, x)			(base + 0x0210 + x)
// 32-bit Operating Conditions Register
#define SD_CARD_OCR(base)				(base + 0x0220)
// 32-bit Card Status Register
#define SD_CARD_STATUS(base)			(base + 0x0224)
// 16-bit Relative Card Address Register
#define SD_CARD_RCA(base)				(base + 0x0228)
// 32-bit Card Argument Register
#define SD_CARD_ARGUMENT(base)			(base + 0x022C)
// 16-bit Card Command Register
#define SD_CARD_COMMAND(base)			(base + 0x0230)
// 16-bit Card Auxiliary Status Register
#define SD_CARD_AUX_STATUS(base)		(base + 0x0234)
// 32-bit R1 Response Register
#define SD_CARD_R1_RESPONSE(base)		(base + 0x0238)

#define CMD_READ_BLOCK					17
#define CMD_WRITE_BLOCK					24

// FAT 12/16 related stuff
//#define BOOT_SECTOR_DATA_SIZE			0x005A
#define MAX_FILES_OPENED				20

/******************************************************************************/
/******  LOCAL DATA STRUCTURES  ***********************************************/
/******************************************************************************/



typedef struct s_FAT_12_16_boot_sector {
	unsigned char jump_instruction[3];
	char OEM_name[8];
	unsigned short int sector_size_in_bytes;
	unsigned char sectors_per_cluster;
	unsigned short int reserved_sectors;
	unsigned char number_of_FATs;
	unsigned short int max_number_of_dir_entires;
	unsigned short int number_of_sectors_in_partition;
	unsigned char media_descriptor;
	unsigned short int number_of_sectors_per_table;
	unsigned short int number_of_sectors_per_track;
	unsigned short int number_of_heads;
	unsigned int number_of_hidden_sectors;
	unsigned int total_sector_count_if_above_32MB;
	unsigned char drive_number;
	unsigned char current_head;
	unsigned char boot_signature;
	unsigned char volume_id[4];
	char volume_label[11];
	unsigned char file_system_type[8];
	unsigned char bits_for_cluster_index;
	unsigned int first_fat_sector_offset;
	unsigned int second_fat_sector_offset;
	unsigned int root_directory_sector_offset;
	unsigned int data_sector_offset;
} t_FAT_12_16_boot_sector;


typedef struct s_file_record {
	unsigned char name[8];
	unsigned char extension[3];
	unsigned char attributes;
	unsigned short int create_time;
	unsigned short int create_date;
	unsigned short int last_access_date;
	unsigned short int last_modified_time;
	unsigned short int last_modified_date;
	unsigned short int start_cluster_index;
	unsigned int file_size_in_bytes;
	/* The following fields are only used when a file has been created or opened. */
	unsigned int current_cluster_index;
    unsigned int current_sector_in_cluster;
	unsigned int current_byte_position;
    // Absolute location of the file record on the SD Card.
    unsigned int file_record_cluster;
    unsigned int file_record_sector_in_cluster;
    short int    file_record_offset;
    // Is this record in use and has the file been modified.
    unsigned int home_directory_cluster;
    bool         modified;
	bool		 in_use;
} t_file_record;


typedef struct s_find_data {
	unsigned int directory_root_cluster; // 0 means root directory.
	unsigned int current_cluster_index;
	unsigned int current_sector_in_cluster;
	short int file_index_in_sector;
	bool valid;
} t_find_data;

///////////////////////////////////////////////////////////////////////////
// extern Variables( 使用Altera_UP_SD_Card_Avalon_Interface.c中的变量 )
///////////////////////////////////////////////////////////////////////////


// Pointers to currently opened files.
extern t_file_record active_files[MAX_FILES_OPENED];
extern t_FAT_12_16_boot_sector boot_sector_data;
extern int fat_partition_offset_in_512_byte_sectors;
extern unsigned int current_sector_index;
extern volatile char *buffer_memory;
///////////////////////////////////////////////////////////////////////////
// Local Functions
///////////////////////////////////////////////////////////////////////////





//自定义函数


//读取文本内容，读取size个字节，放入缓存buffer,返回值为真实读取的字节数
short fread_txt( short file_handle, alt_u8 *buffer, int numInByte )
{
	short int ch = -1;
	//校验file_handle
	if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
	{
		if (active_files[file_handle].in_use)//file_handle对应的文件打开了
		{
			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
			{
				int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
								  active_files[file_handle].current_sector_in_cluster;

				if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
				{
					// Read in a new sector of data.
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
					{
						// Go to the next cluster.
						unsigned short int next_cluster;
						if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
						{
							if ((next_cluster & 0x0000fff8) == 0x0000fff8)
							{
								/* End of file */
								return -1;
							}
							else
							{
								active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
								data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
								  active_files[file_handle].current_sector_in_cluster;
							}
						}
						else
						{
							return -2;
						}
					}
					else
					{
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
						data_sector = data_sector + 1;
					}
				}
				// Reading te first byte of the file.
				if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
				{
					if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
					{
						return -2;
					}
				}

				ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
				active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
			}
		}
	}

	return ch;

}

//文本指针偏移(返回0,成功； 返回-1，失败)
short fseek_txt( short file_handle, int offset, enum fseekType fromwhere )
{
	return 0;
}


//获取当前读取文件的位置(返回值)
long ftell_txt( short file_handle )
{
	return 0;
}


//打开文件
//input: fileReadName( 包含 .TXT )
//Output: file_handle
//An index to the file record assigned to the specified file.
//-1 is returned if the file could not be opened.
//Return -2 if the specified file has already been opened previously.
short fopen_txt( char *fileReadName )
{
	fclose_txt( 0 );//无论上一个关没关，先关了上一个
	return alt_up_sd_card_fopen( fileReadName, false );
}


//关闭文件
//input: file_handle
//output: 0:成功 -1:失败(可能关闭了未打开的文件)
int fclose_txt( short file_handle )
{
	bool status = alt_up_sd_card_fclose( file_handle );
	if ( status )
	{
		return 0;
	}
	return -1;
}
