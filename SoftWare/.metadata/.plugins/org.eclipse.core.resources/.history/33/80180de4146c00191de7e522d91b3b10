/*
 * screen_display.c
 *
 *  Created on: 2019年5月1日
 *      Author: 12757
 */

#include "stdlib.h"
#include "screen_display.h"


//该数组用于临时测试屏幕显示效果，最后的工程会删除该数组
color_u16 screenShowSpace[SCR_HEIGHT][SCR_WIDTH];

//画边界(就是画个长方形的边)
void showBorder( const AreaRange *borderPos, color_u16 borderColor )
{
	int xPos, yPos;
	//横向
	yPos = borderPos->y_min;
	//x方向的边界
	for ( xPos = borderPos->x_min; xPos <= borderPos->x_max; xPos ++ )
	{
		screenShowSpace[yPos-1][xPos-1] = borderColor;
	}
	yPos = borderPos->y_max;
	for ( xPos = borderPos->x_min; xPos <= borderPos->x_max; xPos ++ )
	{
		screenShowSpace[yPos-1][xPos-1] = borderColor;
	}

	//y方向的边界
	xPos = borderPos->x_min;
	for ( yPos = borderPos->y_min + 1; yPos < borderPos->y_max; yPos ++ )
	{
		screenShowSpace[yPos-1][xPos-1] = borderColor;
	}
	xPos = borderPos->x_max;
	for ( yPos = borderPos->y_min + 1; yPos < borderPos->y_max; yPos ++ )
	{
		screenShowSpace[yPos-1][xPos-1] = borderColor;
	}

}

//显示边界与背景
//exceptAreaArray为非背景区的区域数组（区域格式为相对区域）
//bkgBorderColor为颜色信息：背景颜色、边界颜色、边界颜色是否可见(如果不可见，则一律使用背景颜色
//exceptAreaArray[]是非背景区域构成的数组， exceptAreaNum为数组元素个数
//exceptAreaArray[]格式为相对区域位置
//absPos为绝对位置
bool showBkgAndBorder( const ColorInfo *bkgBorderColor, const AreaRange *absPos, const AreaRange exceptAreaArray[], const short exceptAreaNum )
{
	bool status = true;

	short width = absPos->x_max - absPos->x_min + 1;
	short height = absPos->y_max - absPos->y_min + 1;
	short xBasePos = absPos->x_min - 1;
	short yBasePos = absPos->y_min - 1;

	if ( bkgBorderColor->borderVisible )//边界可见
	{
		//画边界
		showBorder( absPos, bkgBorderColor->borderColor );
		//将绝对区域缩小一圈，即除去刚画的边界
		width -= 2;
		height -= 2;
		xBasePos += 1;
		yBasePos += 1;
	}

	//显示背景颜色
	//统计每一行非背景区的像素

	bool *exceptXposInRow = malloc( sizeof(char) * width );


	//此处xPos,yPos为相对位置
	short xPos, yPos;
	for ( yPos = 1; yPos <= height; yPos ++ )
	{
		int i;
		for ( i = 0; i < width; i ++ )
		{
			exceptXposInRow[i] = 0;//清空
		}
		//统计每一行非背景区的像素
		const AreaRange *curExceptArea;
		for ( i = 0; i < exceptAreaNum; i ++ )//遍历每一个非背景区
		{
			curExceptArea = &(exceptAreaArray[i]);
			if ( yPos < curExceptArea->y_min || yPos > curExceptArea->y_max )
			{
				continue;
			}
			else
			{
				for ( xPos = curExceptArea->x_min; xPos <= curExceptArea->x_max; xPos ++ )
				{
					exceptXposInRow[xPos-1] = 1;//对非背景像素做作标记
				}
			}
		}
		//画背景
		color_u16 bkgColor = bkgBorderColor->bkgColor;
		for ( xPos = 1; xPos <= width; xPos ++ )
		{
			if ( !exceptXposInRow[xPos-1] )//背景像素点
			{
				screenShowSpace[yBasePos+yPos-1][xBasePos+xPos-1] = bkgColor;
			}
		}
	}

	free(exceptXposInRow);
	return status;
}

//显示screen_header
bool showScreenHeader( const ScreenHeaderTime *scrHeaderInst, const AreaRange *scrHeaderPos )
{
	bool status = true;

	//显示screen_header的背景与边界
	showBkgAndBorder( &(scrHeaderInst->bkgBorderColor), scrHeaderPos, &(scrHeaderInst->tagTimeArea), 1 );

	//显示时间标签
	AreaRange tagTimeAbsPos;//时间标签绝对位置
	//计算绝对位置
	getAbsPos( scrHeaderPos, &(scrHeaderInst->tagTimeArea), &tagTimeAbsPos );
	//显示Tag
	showTagBlock( &(scrHeaderInst->tagTime), &tagTimeAbsPos );


	return status;
}

//获取新的绝对位置
void getAbsPos( const AreaRange *absPos, const AreaRange *relativePos, AreaRange *newAbsPos )
{
	newAbsPos->x_min = absPos->x_min + relativePos->x_min - 1;
	newAbsPos->x_max = absPos->x_min + relativePos->x_max - 1;
	newAbsPos->y_min = absPos->y_min + relativePos->y_min - 1;
	newAbsPos->y_max = absPos->y_min + relativePos->y_max - 1;
}

//显示TagBlock
bool showTagBlock( const TagBlock *tagPtr, const AreaRange *absPos )
{
	bool status = true;

	//显示TagBlock的背景与边界
	showBkgAndBorder( &(tagPtr->tagColorInfo), absPos, &(tagPtr->textArea), 1 );

	return status;
}

//显示IconBlock
bool showIconBlock( const IconBlock *blockPtr, const AreaRange *absPos )
{
	bool status = true;

	//显示IconBlock的背景与边界
	bool iconPicVisible = (blockPtr->iconColorInfo).objVisible;

	if ( iconPicVisible )//中间的icon需要显示
	{
		//处理背景与边界（挖掉iconPic显示区）
		showBkgAndBorder( &(blockPtr->iconColorInfo), absPos, &(blockPtr->picArea), 1 );

		//显示中间的icon图片

		color_u16 bkgColor = (blockPtr->iconColorInfo).bkgColor;
		color_u16 iconPicColor = (blockPtr->iconColorInfo).objColor;

		short width = absPos->x_max - absPos->x_min + 1;
		short height = absPos->y_max - absPos->y_min + 1;
		short xBasePos = absPos->x_min - 1;
		short yBasePos = absPos->y_min - 1;

		const alt_u8 *iconPicPtr = blockPtr->iconPic;
		alt_u8 iconPicRowPixel;//横向的像素

		//xPos,yPos为相对位置
		short xPos, yPos;
		short iconPicIndex = 0;
		for ( yPos = 1; yPos <= height; yPos ++ )
		{
			for ( xPos = 1; xPos <= width; xPos ++ )
			{
				if ( (xPos & 0x7) == 0x1 )//xPos低三位为001（等效为xPos % 8 == 1 )
				{
					iconPicRowPixel = iconPicPtr[iconPicIndex];
					iconPicIndex ++;
				}
				if ( (iconPicRowPixel & 0x80) == 0x80 )//最高位为1
				{
					screenShowSpace[yBasePos+yPos-1][xBasePos+xPos-1] = bkgColor;
				}
				else
				{
					screenShowSpace[yBasePos+yPos-1][xBasePos+xPos-1] = iconPicColor;
				}
				iconPicRowPixel = iconPicRowPixel<<1;//左移一位，将新像素信息移至最高位
			}
		}

	}
	else//中间的icon不需要显示
	{
		//只处理背景与边界颜色
		showBkgAndBorder( &(blockPtr->iconColorInfo), absPos, NULL, 0 );
	}

	return status;
}
